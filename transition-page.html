<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Estate Grid 3D Transition</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background: radial-gradient(circle at center, #0b1d2a 0%, #000 80%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: "Poppins", sans-serif;
        }

        a {
            text-decoration: none;
            font-size: 22px;
            color: #ffd166;
            border: 2px solid #ffd166;
            padding: 14px 28px;
            border-radius: 8px;
            background: rgba(255, 209, 102, 0.05);
            transition: 0.3s;
            z-index: 10;
            position: relative;
        }

        a:hover {
            background: #ffd166;
            color: #0b1d2a;
        }

        /* Fade trắng */
        #fade-overlay {
            position: fixed;
            inset: 0;
            background: white;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            z-index: 9999;
            pointer-events: none;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>

    <a href="https://example.com" id="goRealEstate">Khám phá dự án</a>
    <div id="fade-overlay"></div>

    <!-- THREE.js -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script>
        let scene, camera, renderer, cubes = [];

        const fade = document.getElementById("fade-overlay");
        const link = document.getElementById("goRealEstate");

        // Responsive grid size
        function getGridSize() {
            const isMobile = window.innerWidth < 768;
            return isMobile ? { rows: 14, cols: 8 } : { rows: 20, cols: 36 };
        }

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0b1d2a);
            document.body.appendChild(renderer.domElement);

            // Ánh sáng mềm
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            const point = new THREE.PointLight(0xffd166, 1.2);
            point.position.set(0, 5, 10);
            scene.add(ambient, point);

            const { rows, cols } = getGridSize();
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd166,
                emissive: 0xffd166,
                emissiveIntensity: 0.15,
                metalness: 0.4,
                roughness: 0.4,
            });

            const spacing = 1.2;
            const startX = -(cols - 1) * spacing * 0.5;
            const startY = -(rows - 1) * spacing * 0.5;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cube = new THREE.Mesh(geometry, material.clone());
                    cube.position.set(startX + c * spacing, startY + r * spacing, 0);
                    cube.scale.set(0, 0, 0);
                    cubes.push({ mesh: cube, r, c });
                    scene.add(cube);
                }
            }

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Hiệu ứng lan tỏa
        function triggerTransition(href) {
            const { rows, cols } = getGridSize();
            const centerR = rows / 2;
            const centerC = cols / 2;

            cubes.forEach(({ mesh, r, c }) => {
                const dist = Math.hypot(r - centerR, c - centerC);
                const delay = dist * 0.03;

                gsap.to(mesh.scale, {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: 0.5,
                    delay: delay,
                    ease: "back.out(1.7)",
                    onComplete: () => {
                        gsap.to(mesh.scale, {
                            x: 0,
                            y: 0,
                            z: 0,
                            duration: 0.6,
                            delay: 0.15,
                            ease: "power2.inOut",
                        });
                    },
                });

                gsap.to(mesh.rotation, {
                    y: "+=" + Math.random() * 1.5,
                    x: "+=" + Math.random() * 1.5,
                    delay: delay,
                    duration: 0.8,
                    ease: "sine.inOut",
                });
            });

            // Fade trắng
            setTimeout(() => (fade.style.opacity = "1"), 1600);
            setTimeout(() => (window.location.href = href), 2500);
        } let audioCtx = null;
        function playSyntheticClick({ volume = 0.6, frequency = 1400, length = 0.03 } = {}) {
            // create on first use (user gesture required by browsers; click count is such)
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            const now = audioCtx.currentTime;
            // short noise burst + click-like oscillator with envelope
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            // oscillator: high freq for "click"
            osc.type = 'square';
            osc.frequency.setValueAtTime(frequency, now);

            // envelope
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + 0.001);
            gain.gain.exponentialRampToValueAtTime(0.001, now + length);

            // small bandpass to make it crisp
            const biquad = audioCtx.createBiquadFilter();
            biquad.type = 'highpass';
            biquad.frequency.value = 700;

            osc.connect(biquad);
            biquad.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start(now);
            osc.stop(now + length + 0.02);
        }

        let ctx;
        function playHoverChime() {
            if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
            const t0 = ctx.currentTime;

            const tone = ctx.createOscillator();
            const gain = ctx.createGain();

            tone.type = 'sine';
            tone.frequency.setValueAtTime(900, t0);
            tone.frequency.exponentialRampToValueAtTime(2000, t0 + 0.3);

            gain.gain.setValueAtTime(0.0001, t0);
            gain.gain.exponentialRampToValueAtTime(0.15, t0 + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.4);

            const delay = ctx.createDelay();
            delay.delayTime.setValueAtTime(0.12, t0);

            const fb = ctx.createGain();
            fb.gain.setValueAtTime(0.25, t0);
            delay.connect(fb);
            fb.connect(delay);

            tone.connect(gain).connect(delay).connect(ctx.destination);
            gain.connect(ctx.destination);

            tone.start(t0);
            tone.stop(t0 + 0.4);
        }

        function playFuturisticLuxuryClick() {
            if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
            const t0 = ctx.currentTime;

            // Click spark
            const spark = ctx.createOscillator();
            spark.type = 'triangle';
            spark.frequency.setValueAtTime(700, t0);
            spark.frequency.exponentialRampToValueAtTime(2800, t0 + 0.06);
            const sparkGain = ctx.createGain();
            sparkGain.gain.setValueAtTime(0.001, t0);
            sparkGain.gain.exponentialRampToValueAtTime(0.25, t0 + 0.02);
            sparkGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.25);

            // Shimmer
            const shimmer = ctx.createOscillator();
            shimmer.type = 'sine';
            shimmer.frequency.setValueAtTime(1500, t0);
            shimmer.frequency.exponentialRampToValueAtTime(3800, t0 + 0.7);
            const shimmerGain = ctx.createGain();
            shimmerGain.gain.setValueAtTime(0.0001, t0);
            shimmerGain.gain.exponentialRampToValueAtTime(0.18, t0 + 0.08);
            shimmerGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 1);

            // Low hum
            const hum = ctx.createOscillator();
            hum.type = 'sine';
            hum.frequency.setValueAtTime(100, t0);
            hum.frequency.exponentialRampToValueAtTime(70, t0 + 1);
            const humGain = ctx.createGain();
            humGain.gain.setValueAtTime(0.06, t0);
            humGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 1);

            const delay = ctx.createDelay();
            delay.delayTime.setValueAtTime(0.16, t0);
            const fb = ctx.createGain();
            fb.gain.setValueAtTime(0.3, t0);
            delay.connect(fb);
            fb.connect(delay);

            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(2200, t0);

            delay.connect(filter);
            filter.connect(ctx.destination);

            const mix = ctx.createGain();
            mix.gain.setValueAtTime(0.8, t0);

            spark.connect(sparkGain).connect(mix);
            shimmer.connect(shimmerGain).connect(mix);
            hum.connect(humGain).connect(mix);
            mix.connect(delay);
            mix.connect(ctx.destination);

            spark.start(t0);
            spark.stop(t0 + 0.25);
            shimmer.start(t0 + 0.05);
            shimmer.stop(t0 + 1);
            hum.start(t0);
            hum.stop(t0 + 1);
        }


        link.addEventListener("click", (e) => {
            // playSyntheticClick({ volume: 0.5, frequency: 1600, length: 0.028 });
            playFuturisticLuxuryClick();
            e.preventDefault();
            triggerTransition(e.target.href);
        });

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>

</html>